先介绍C语言使用GCC的编译过程
![[Pasted image 20231110114305.png]]

然后演示其它的预处理配置
![[Pasted image 20231110114624.png]]
代码示例
![[Pasted image 20231110114439.png]]
![[Pasted image 20231110114459.png]]

![[Pasted image 20231110114642.png]]
![[Pasted image 20231110114659.png]]
示例：
进行GDB调试
![[Pasted image 20231110114723.png]]

因为剩下的时间不够了，所以就随便讲了讲
![[Pasted image 20231110115536.png]]
查看Ubuntu使用的哪个C语言标准
gcc -v命令

然后老师讲了头文件的制作
直接编写代码来制作头文件
如果这样子写，会让编写代码的代码量很大
![[Pasted image 20231110141205.png]]
为了解决这种重复代码的问题，就引入了头文件来减少代码量
![[Pasted image 20231110141555.png]]
当重复导入`head.h`时，就需要使用宏来避免重复定义的问题
![[Pasted image 20231110142001.png]]
老师讲了宏的命名约定：使用文件名来当作宏，比如之类的文件名为`head.h`，所以宏为`_HEAD_H`

然后老师提问，为什么要编写函数声明：防止编译器报错
因为其它地方可能也需要使用fun函数，因此将fun的外部声明放到头文件中
![[Pasted image 20231110142857.png]]
只需要知道，多文件编程中的头文件用于存取合并的同类项即可

头文件`""`与`<>`之间的区别
![[Pasted image 20231110143535.png]]
![[Pasted image 20231110143737.png]]
![[Pasted image 20231110143849.png]]



接下来介绍GDB调试
![[Pasted image 20231110144215.png]]
程序通过了编译，但是我的执行结果不是我所期望的
![[Pasted image 20231110144429.png]]
这里打错了，应该是运行出错

![[Pasted image 20231110144453.png]]
![[Pasted image 20231110144518.png]]
![[Pasted image 20231110144608.png]]
![[Pasted image 20231110145159.png]]
`gcc -g file_name.c`

然后老师随便写了个代码，然后调试运行
![[Pasted image 20231110144843.png]]
运行结果有段错误

然后，演示了gdb的使用方式
编译时加-g配置项
![[Pasted image 20231110145036.png]]
使用gdb工具打开程序生成的文件
![[Pasted image 20231110145045.png]]

![[Pasted image 20231110145648.png]]
在gdb应用里输入以下内容并进行回车，会有相应的操作
![[Pasted image 20231110145906.png]]
![[Pasted image 20231110145751.png]]
![[Pasted image 20231110150104.png]]
