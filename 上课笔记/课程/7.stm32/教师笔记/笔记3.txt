
1. （二进）位运算符

   << 左移
   >> 右移
   &  按位与，对应位都为 1 结果才为 1，否则为 0。0 & ? = 0，1 & ? = ?
   |  按位或，对应位都为 0 结果才为 0，否则为 1。1 | ? = 1，0 | ? = ?
   ^  按位异或，对应位相同为 0，不同为 1。       0 ^ ? = ?，1 ^ ? = ~?
   ~  按位取反，每位反转，由 0 变为 1，由 1 变为 0
   
2. 位清 0

   例：对 ODR 寄存器的第 9 位清 0。---- 对某个位清 0
   
   ODR &= ~(1 << 9);

   例：对 ODR 寄存器的第 [5][3][2] 位清 0。---- 对某些位清 0
   
   ODR &= ~((1 << 5) | (1 << 3) | (1 << 2));
   
   例：对 CRH 寄存器的第 [27:24] 位清 0。---- 对连续的位清 0

   CRH &= ~(0xF << 24);

3. 位置 1

   例：对 ODR 寄存器的第 9 位置 1。---- 对某个位置 1
   
   ODR |= 1 << 9;
   
   例：对 ODR 寄存器的第 [5][3][2] 位置 1。---- 对某些位置 1
   
   ODR |= (1 << 5) | (1 << 3) | (1 << 2);
   
   例：对 CRH 寄存器的第 [27:24] 位置 1。---- 对连续的位置 1
   
   CRH |= 0xF << 24;

4. 位取反

   例：对 ODR 寄存器的第 9 位取反。---- 对某个位取反
   
   ODR ^= 1 << 9;

   例：对 ODR 寄存器的第 [5][3][2] 位取反。---- 对某些取反

   ODR ^= (1 << 5) | (1 << 3) | (1 << 2);

   例：对 CRH 寄存器的第 [27:24] 位取反。---- 对连续位取反
   
   ODR ^= 0xF << 24;

5. volatile 的作用

   在没有使用 volatile 修饰变量的情况下，如果进行优化编译，则编译器会对变量进行以下优化：
   
   . 指令重排。为了加快运行速度，可能对文本代码编译出的机器指令，进行重新排序。如：
   
     代码文本是这样的：
	 
     a = 1;
	 b = 2;
	 
     编译器重排后变成：
	 
	 b = 2;
	 a = 1;
	 
	 这样的重新排列，对纯内存变量，没什么影响，但对寄存器的操作则可能有很大的影响。如：
	 
	 GPIOC->CRH &= ~(0xF << 4);
	 GPIOC->CRH |= 0x3 << 4;   

     以上赋值的顺序不能重排。为了告诉编译器不要对 CRH 进行指令重排，加 volatile 修饰即可。
	 
   . 对变量进行缓存。为了加快运行速度，可能将变量存储到 CPU 寄存器中，或存储到缓存中。
     这样如果存在多个任务/线程，或者在普通程序与中断处理函数中共享同一个变量的情况，
	 说法会造成内存访问的不一致情况出现。
     
	 使用 volatile 修饰的变量，编译器不能对其进行缓存。确保每次访问的都是同一个内存空间。

   . 存储删除。编译器为了加快运行速度，对连续赋值的同一变量，只保留最后一次赋值，而删除
     了前面的赋值语句。如：
	 
	 a = 1;
	 a = 2;
	 a = 3;
	 a = 4;
	 
	 编译器只保留 a = 4; 语句，前面的语句被删除了。
	 但是对于寄存器的操作会经常出现这种连续赋值的情况。
	 
     GPIOC->CRH &= ~(0xF << 4);
	 GPIOC->CRH |= 0x3 << 4;
	 
	 每一步都有作用，不能将前面的语句删除掉。使用 volatile 修饰的变量就不会进行这样的优化了。




