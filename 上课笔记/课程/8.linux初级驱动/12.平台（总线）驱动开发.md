[一张图掌握 Linux platform 平台设备驱动框架](https://blog.csdn.net/qq_16504163/article/details/118562670)
介绍操作寄存器的方式

介绍实例化全局设备对象函数--kzalloc()

介绍了不适合的驱动开发的代码过程
前面介绍的驱动的开发方式，都是传统的开发方式
代码重复性太多，比如，uart1、2、3，传统驱动都是需要写三份代码
而如果使用分离性的思想，就会减少代码重复性太高的问题：
比如uart的初始化、发送接收的操作是相似的，只是硬件地址不一样，传递的数据不一样，我们只需要封装好驱动公用的代码即可

画图介绍了平台（总线）驱动开发方式
为了解决上述问题，就有了平台（总线）驱动开发方式
![[Pasted image 20240118092717.png]]
平台总线是虚拟的总线，是linux虚拟出来的
这种方式开发效率更高
相关的结构体：platform_driver
在day04的笔记里有相关的介绍

![[Pasted image 20240201095331.png]]
根据图，想要理清平台总线的内容，就需要理解以下问题：
# 理解平台总线
## 与平台总线相关的内容里有什么？
platform_driver（结构体）
bus_type（结构体）
platform_device（结构体）

## 与平台总线相关的内容的各个部分的作用，作用是什么？
### platform_driver
1. 确定驱动的名字
2. 在bus_type的实例调用platform_match方法时，有probe函数执行
3. 在卸载驱动时，有remove函数执行
### bus_type
1. 用于保存平台驱动结构体的注册
2. 用于保存平台设备结构体的注册
3. 当有驱动或设备加载到当前总线时，执行匹配函数，实现驱动或设备的probe函数
### platform_device
1. 确定设备的名字，这个名字用于bus_type的匹配函数
## 平台总线实现的流程是什么？
1. 创建platform_driver结构体的实例
2. 确定需要编写驱动的设备的名字
3. 编写probe函数
4. 编写remove函数
5. 编写